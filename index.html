<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ISF Card Engine V18.0 (Explicit Core)</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>
<body>
    <script>
    (function() {
        /* ISF OFFICIAL ENGINE V18.0
           - Architecture: Explicit "Foundation/Draw" arrays (No splicing errors).
           - Logic: Strict 52 Conservation & Repatriation.
           - Feature: Nicknames, Live Countdown, "New Card Reveal".
           - Visuals: Restored Green Stadium & White/Green Card styles.
        */

        // 1. CONSTANTS & SETUP
        const SUITS = [' ♥ ', ' ♦ ', ' ♣ ', ' ♠ '];
        const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const RANKS = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };

        // 2. GAME STATE (EXPLICIT ARRAYS)
        let myFoundation = [];
        let myDraw = [];
        let myPenalty = [];
        
        let oppFoundation = [];
        let oppDraw = [];
        let oppPenalty = [];
        
        let centerStack = [];
        let isBorrowing = { me: false, opp: false };
        
        // GAMEPLAY FLAGS
        let hasPassed = { me: false, opp: false };
        let activeRanks = { left: null, right: null }; // Left=Secondary, Right=Active
        let isLocked = false;
        let slapInProgress = false;
        let gameActive = false;
        
        // NETWORK STATE
        let peer = null;
        let conn = null;
        let isHost = false;
        let myNick = "Player 1";
        let oppNick = "Opponent";
        
        // STATS
        let stats = { myRounds: 0, mySlaps: 0, oppRounds: 0, oppSlaps: 0 };
        let zIndexCounter = 100;

        // 3. UI GENERATION
        document.body.innerHTML = `
        <style>
            :root { --bg: #1a4731; --gold: #f1c40f; --red: #e74c3c; }
            body { background: var(--bg); color: white; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; user-select: none; }
            .screen { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: var(--bg); z-index: 2000; }
            .hidden { display: none !important; }
            
            h1 { font-size: 80px; color: #ff7575; margin: 0; letter-spacing: 5px; font-family: serif; }
            button { background: transparent; border: 2px solid white; color: white; padding: 15px 40px; font-size: 18px; margin: 10px; cursor: pointer; width: 250px; font-weight: bold; transition: 0.2s; }
            button:hover { background: white; color: var(--bg); }
            button.disabled { opacity: 0.5; cursor: not-allowed; }
            input { background: rgba(0,0,0,0.5); border: 2px solid white; color: gold; font-size: 24px; text-align: center; padding: 10px; width: 250px; text-transform: uppercase; }
            
            #stadium { display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 100vh; padding: 20px 0; }
            
            .foundation-zone { position: relative; width: 900px; height: 240px; border: 4px solid white; background: rgba(0,0,0,0.1); }
            .opp-zone { transform: rotate(180deg); }
            
            #center-zone { display: flex; gap: 40px; align-items: center; position: relative; z-index: 500; }
            
            .draw-btn { width: 100px; height: 140px; border: 3px solid white; border-radius: 10px; background: #1e3a5f; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; cursor: pointer; position: relative; transition: 0.2s; box-shadow: 0 5px 0 #0d1b2a; text-align: center; }
            .draw-btn.ready { background: #27ae60 !important; transform: scale(1.05); }
            
            .slot { width: 110px; height: 155px; border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; }
            
            .card { width: 100px; height: 140px; border-radius: 8px; border: 1px solid #777; background: white; color: black; position: absolute; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.3); transition: transform 0.1s; }
            .card.red { color: var(--red); }
            .card.face-down { background: #2c3e50; color: transparent !important; background-image: repeating-linear-gradient(45deg, #34495e, #34495e 5px, #2c3e50 5px, #2c3e50 10px); }
            
            .card-corner { position: absolute; display: flex; flex-direction: column; align-items: center; font-size: 18px; line-height: 1; }
            .tl { top: 5px; left: 5px; }
            .br { bottom: 5px; right: 5px; transform: rotate(180deg); }
            .suit-center { font-size: 48px; }
            
            .hud { position: absolute; left: 30px; bottom: 30px; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 12px; border-left: 8px solid gold; font-size: 32px; font-weight: bold; }
            .hud.opp { bottom: auto; top: 30px; border-left-color: var(--red); }
            
            #alert-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 60px; font-weight: 900; color: gold; text-shadow: 0 0 20px black; display: none; z-index: 9000; pointer-events: none; white-space: nowrap; }
            #victory-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; display: none; flex-direction: column; align-items: center; justify-content: center; }
            
            #scoreboard { position: absolute; top: 65px; right: 20px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; text-align: right; font-family: monospace; font-weight: bold; }
        </style>

        <div id="screen-menu" class="screen">
            <h1>ISF</h1>
            <button id="btn-online-menu" style="border-color: gold; color: gold;">PLAY ONLINE</button>
        </div>

        <div id="screen-online" class="screen hidden">
            <h1>MULTIPLAYER</h1>
            <input type="text" id="nick-input" placeholder="NICKNAME" maxlength="12">
            <button id="btn-host">HOST GAME</button>
            <button id="btn-join">JOIN GAME</button>
            <button onclick="location.reload()" style="border:none; margin-top:20px; font-size:14px;">BACK</button>
        </div>

        <div id="screen-lobby" class="screen hidden" style="background:#111;">
            <div style="font-size:24px; color:gold;">YOUR ROOM CODE</div>
            <div id="room-code" style="font-size:60px; border:4px dashed #555; padding:10px 40px; margin:20px;">...</div>
            <div id="lobby-status" style="font-size:24px; margin-bottom:20px;">Waiting for opponent...</div>
            <button id="btn-start" class="disabled">START MATCH</button>
            <button onclick="location.reload()" style="border:none; margin-top:20px; font-size:14px;">CANCEL</button>
        </div>

        <div id="screen-connect" class="screen hidden" style="background:#111;">
            <div style="font-size:24px; color:gold;">ENTER CODE</div>
            <input type="text" id="join-input">
            <button id="btn-connect-action">CONNECT</button>
            <div id="connect-status" style="margin-top:20px;"></div>
            <button onclick="location.reload()" style="border:none; margin-top:20px; font-size:14px;">CANCEL</button>
        </div>

        <div id="stadium" class="hidden">
            <div id="scoreboard">
                <div style="color:gold;">YOU - R:<span id="s-mr">0</span> S:<span id="s-ms">0</span></div>
                <div style="color:#ff7575;">OPP - R:<span id="s-or">0</span> S:<span id="s-os">0</span></div>
            </div>
            
            <div id="alert-box">SLAP!</div>
            
            <div id="victory-overlay">
                <h1 id="vic-msg" style="color:gold;">VICTORY</h1>
                <button onclick="location.reload()">MAIN MENU</button>
            </div>

            <div class="hud opp"><small id="lbl-opp">OPPONENT</small><br><span id="cnt-opp">26</span></div>
            <div id="zone-opp" class="foundation-zone opp-zone"></div>

            <div id="center-zone">
                <div id="btn-opp" class="draw-btn">OPPONENT</div>
                <div id="slot-l" class="slot"></div>
                <div id="slot-r" class="slot"></div>
                <div id="btn-me" class="draw-btn">NEW CARD REVEAL</div>
            </div>

            <div id="zone-me" class="foundation-zone"></div>
            <div class="hud"><small id="lbl-me">YOU</small><br><span id="cnt-me">26</span></div>
        </div>
        `;

        // 4. MENU LOGIC
        const $ = (id) => document.getElementById(id);
        
        $('btn-online-menu').onclick = () => { $('screen-menu').classList.add('hidden'); $('screen-online').classList.remove('hidden'); };
        
        $('btn-host').onclick = () => {
            myNick = $('nick-input').value.toUpperCase() || "HOST";
            isHost = true;
            $('screen-online').classList.add('hidden');
            $('screen-lobby').classList.remove('hidden');
            initNetwork();
        };

        $('btn-join').onclick = () => {
            myNick = $('nick-input').value.toUpperCase() || "GUEST";
            $('screen-online').classList.add('hidden');
            $('screen-connect').classList.remove('hidden');
        };

        $('btn-connect-action').onclick = () => {
            let code = $('join-input').value.toUpperCase();
            if(code) { isHost = false; initNetwork(code); }
        };

        $('btn-start').onclick = () => {
            if(!conn) return;
            startNewMatch();
        };

        // 5. NETWORK CORE
        function initNetwork(targetId = null) {
            if(isHost) {
                netId = 'ISF-' + Math.floor(Math.random()*9000+1000);
                $('room-code').innerText = netId;
                peer = new Peer(netId);
                peer.on('connection', (c) => {
                    conn = c;
                    setupDataListener();
                    $('lobby-status').innerText = "PLAYER CONNECTED!";
                    $('lobby-status').style.color = "#2ecc71";
                    $('btn-start').classList.remove('disabled');
                });
            } else {
                peer = new Peer();
                peer.on('open', () => {
                    $('connect-status').innerText = "Connecting...";
                    conn = peer.connect(targetId);
                    conn.on('open', () => {
                        $('connect-status').innerText = "WAITING FOR HOST...";
                        $('connect-status').style.color = "#2ecc71";
                        setupDataListener();
                    });
                });
            }
        }

        function setupDataListener() {
            conn.on('data', (data) => {
                switch(data.type) {
                    case 'INIT_MATCH':
                        oppNick = data.hostNick;
                        conn.send({ type: 'NICK_REPLY', nick: myNick });
                        startGame(data.p2Found, data.p2Draw, data.p1Found, data.p1Draw);
                        break;
                    case 'NICK_REPLY':
                        oppNick = data.nick;
                        updateLabels();
                        break;
                    case 'SYNC_ROUND':
                        // Swap perspectives: Host sent P1/P2. Joiner needs P2/P1.
                        if(!isHost) {
                            startRound(data.p2Found, data.p2Draw, data.p1Found, data.p1Draw);
                            // Update Scoreboard (Swapped)
                            stats.myRounds = data.stats.oppRounds;
                            stats.oppRounds = data.stats.myRounds;
                            stats.mySlaps = data.stats.oppSlaps;
                            stats.oppSlaps = data.stats.mySlaps;
                            updateScoreboard();
                            alert(`${data.winner === 'p1' ? oppNick : myNick} WINS ROUND!`);
                        }
                        break;
                    case 'PASS':
                        handleOpponentPass();
                        break;
                    case 'COUNTDOWN':
                        updateCountdown(data.count);
                        break;
                    case 'REVEAL':
                        executeReveal(data.c1, data.c2);
                        break;
                    case 'MOVE':
                        executeOpponentMove(data.card, data.targetId);
                        break;
                    case 'FLIP':
                        executeOpponentFlip(data.rank, data.suit);
                        break;
                    case 'SLAP_REQ':
                        if(isHost) processSlap('p2');
                        break;
                    case 'SLAP_WIN':
                        handleSlapWin(data.winner, data.stack);
                        break;
                    case 'ROUND_OVER':
                        if(isHost) resolveRound(data.winner);
                        break;
                    case 'GAME_OVER':
                        endGame(data.winner);
                        break;
                }
            });
        }

        // 6. GAME LOGIC
        function generateDeck() {
            let deck = [];
            SUITS.forEach(s => VALUES.forEach(v => {
                deck.push({ s, v, rank: RANKS[v], color: (s.includes('♥')||s.includes('♦')) ? 'red' : 'black', id: Math.random().toString(36) });
            }));
            return deck.sort(() => Math.random() - 0.5);
        }

        function startNewMatch() {
            let fullDeck = generateDeck();
            // Split 52 into two chunks of 26
            let p1Chunk = fullDeck.slice(0, 26);
            let p2Chunk = fullDeck.slice(26, 52);
            
            // Tag Ownership
            p1Chunk.forEach(c => c.owner = 'p1');
            p2Chunk.forEach(c => c.owner = 'p2');

            // Split into Foundation (10) and Draw (16)
            let p1F = p1Chunk.slice(0, 10);
            let p1D = p1Chunk.slice(10, 26);
            
            let p2F = p2Chunk.slice(0, 10);
            let p2D = p2Chunk.slice(10, 26);

            // Send to Joiner
            conn.send({ 
                type: 'INIT_MATCH', 
                hostNick: myNick,
                p1Found: p1F, p1Draw: p1D, // Host Data
                p2Found: p2F, p2Draw: p2D  // Joiner Data
            });

            startGame(p1F, p1D, p2F, p2D);
        }

        function startGame(myF, myD, oppF, oppD) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            $('stadium').classList.remove('hidden');
            gameActive = true;
            updateLabels();
            startRound(myF, myD, oppF, oppD);
        }

        function startRound(myF, myD, oppF, oppD) {
            // Reset State
            myFoundation = myF; myDraw = myD; myPenalty = [];
            oppFoundation = oppF; oppDraw = oppD; oppPenalty = [];
            centerStack = [];
            hasPassed = { me: false, opp: false };
            activeRanks = { left: null, right: null };
            isLocked = false;
            slapInProgress = false;
            
            // Clear UI
            $('zone-me').innerHTML = '';
            $('zone-opp').innerHTML = '';
            $('slot-l').innerHTML = '';
            $('slot-r').innerHTML = '';
            $('btn-me').classList.remove('ready', 'counting');
            $('btn-me').innerText = "NEW CARD REVEAL";
            $('btn-opp').classList.remove('ready', 'counting');
            $('btn-opp').innerText = oppNick;

            // Render
            renderFoundation(myFoundation, $('zone-me'), true);
            renderFoundation(oppFoundation, $('zone-opp'), false);
            updateCounts();
            
            // Check Instant Win
            if(myFoundation.length === 0 && myDraw.length === 0) endGame('me');
            if(oppFoundation.length === 0 && oppDraw.length === 0) endGame('opp');
        }

        function renderFoundation(cards, container, isMe) {
            let piles = [[],[],[],[]];
            let counts = [4, 3, 2, 1];
            let cIdx = 0;
            
            // Distribute 10 cards into 4 piles
            counts.forEach((cnt, i) => {
                for(let j=0; j<cnt; j++) {
                    if(cards[cIdx]) piles[i].push(cards[cIdx]);
                    cIdx++;
                }
            });

            let startX = 80;
            piles.forEach(pile => {
                pile.forEach((cardData, idx) => {
                    let isTop = (idx === pile.length - 1);
                    let card = createCardEl(cardData, isTop ? false : true); // Face up if top
                    card.style.left = startX + 'px';
                    card.style.top = (30 + idx * 35) + 'px';
                    
                    if(isMe && isTop) makeDraggable(card); // Only my top cards draggable
                    container.appendChild(card);
                });
                startX += 200;
            });
        }

        function createCardEl(data, faceDown) {
            let el = document.createElement('div');
            el.className = `card ${data.color} ${faceDown ? 'face-down' : ''}`;
            el.dataset.rank = data.rank;
            el.dataset.suit = data.s;
            el.dataset.val = data.v;
            el.dataset.owner = data.owner;
            el.innerHTML = `
                <div class="card-corner tl"><div>${data.v}</div><div>${data.s}</div></div>
                <div class="suit-center">${data.s}</div>
                <div class="card-corner br"><div>${data.v}</div><div>${data.s}</div></div>
            `;
            return el;
        }

        function makeDraggable(card) {
            card.onmousedown = (e) => {
                if(isLocked) return;
                zIndexCounter++; card.style.zIndex = zIndexCounter;
                let startX = card.style.left; let startY = card.style.top;
                let shiftX = e.clientX - card.getBoundingClientRect().left;
                let shiftY = e.clientY - card.getBoundingClientRect().top;

                const moveAt = (pageX, pageY) => {
                    card.style.left = pageX - shiftX - $('zone-me').getBoundingClientRect().left + 'px';
                    card.style.top = pageY - shiftY - $('zone-me').getBoundingClientRect().top + 'px';
                };

                const onMouseMove = (e) => moveAt(e.pageX, e.pageY);

                document.addEventListener('mousemove', onMouseMove);

                card.onmouseup = (e) => {
                    document.removeEventListener('mousemove', onMouseMove);
                    card.onmouseup = null;
                    
                    // Check Drop on Center
                    let dropTarget = getDropTarget(e.clientX, e.clientY);
                    if(dropTarget) {
                        playCard(card, dropTarget);
                    } else {
                        // Snap back
                        card.style.left = startX;
                        card.style.top = startY;
                    }
                };
            };
        }

        function getDropTarget(x, y) {
            let rL = $('slot-l').getBoundingClientRect();
            let rR = $('slot-r').getBoundingClientRect();
            
            if (x > rL.left && x < rL.right && y > rL.top && y < rL.bottom) return { id: 'slot-l', rank: activeRanks.left };
            if (x > rR.left && x < rR.right && y > rR.top && y < rR.bottom) return { id: 'slot-r', rank: activeRanks.right };
            return null;
        }

        function playCard(cardEl, target) {
            let cardRank = parseInt(cardEl.dataset.rank);
            // Logic: +/- 1 or empty
            if (target.rank === null || Math.abs(cardRank - target.rank) === 1 || Math.abs(cardRank - target.rank) === 12) {
                
                // Remove from My Foundation Array
                removeFromFoundation(myFoundation, cardRank, cardEl.dataset.suit);
                
                // Add to Center
                let cardData = { 
                    rank: cardRank, s: cardEl.dataset.suit, v: cardEl.dataset.val, 
                    color: cardEl.classList.contains('red')?'red':'black', owner: cardEl.dataset.owner 
                };
                centerStack.push(cardData);
                
                // Update Local State
                if(target.id === 'slot-l') activeRanks.left = cardRank;
                else activeRanks.right = cardRank;
                
                // Render Locally
                placeCardInSlot(cardData, target.id);
                cardEl.remove();
                
                // Send Move
                conn.send({ 
                    type: 'MOVE', 
                    card: cardData, 
                    targetId: (target.id === 'slot-l' ? 'slot-r' : 'slot-l') // Mirror for opponent
                });
                
                updateCounts();
                checkRoundWin();
            } else {
                // Illegal move animation or snap back handled by mouseup
            }
        }

        function placeCardInSlot(data, slotId) {
            let slot = $(slotId);
            slot.innerHTML = '';
            let c = createCardEl(data, false);
            c.style.position = 'relative';
            c.style.left = 0; c.style.top = 0;
            slot.appendChild(c);
        }

        function executeOpponentMove(data, targetId) {
            // Update Opponent Foundation Count (Just remove last one for visual sync)
            oppFoundation.pop(); 
            
            centerStack.push(data);
            if(targetId === 'slot-l') activeRanks.left = data.rank;
            else activeRanks.right = data.rank;
            
            placeCardInSlot(data, targetId);
            updateCounts();
        }

        // 7. DRAW & REVEAL
        $('btn-me').onclick = () => {
            if(isLocked || hasPassed.me) return;
            hasPassed.me = true;
            $('btn-me').classList.add('ready');
            conn.send({ type: 'PASS' });
            checkRevealTrigger();
        };

        function handleOpponentPass() {
            hasPassed.opp = true;
            $('btn-opp').classList.add('ready');
            $('btn-opp').innerText = "READY";
            checkRevealTrigger();
        }

        function checkRevealTrigger() {
            if(hasPassed.me && hasPassed.opp) {
                isLocked = true;
                if(isHost) startCountdown();
            }
        }

        function startCountdown() {
            let c = 3;
            let timer = setInterval(() => {
                conn.send({ type: 'COUNTDOWN', count: c });
                updateCountdown(c);
                c--;
                if(c < 0) {
                    clearInterval(timer);
                    triggerReveal();
                }
            }, 800);
        }

        function updateCountdown(num) {
            $('btn-me').innerText = num;
            $('btn-opp').innerText = num;
            $('btn-me').classList.add('counting');
            $('btn-opp').classList.add('counting');
        }

        function triggerReveal() {
            // Host Logic for drawing cards
            if(myDraw.length === 0) borrowCards('p1');
            if(oppDraw.length === 0) borrowCards('p2');
            
            let c1 = myDraw.pop();
            let c2 = oppDraw.pop();
            
            // Check for Empty (Game Over?)
            if(!c1 || !c2) { location.reload(); return; } // Safety
            
            conn.send({ type: 'REVEAL', c1: c1, c2: c2 }); // Host sends both
            executeReveal(c1, c2);
        }

        function executeReveal(myC, oppC) {
            // Update Data
            if(!isHost) {
                // Joiner must pop their own logical array to keep count sync
                if(myDraw.length === 0) myDraw = []; // Should handle borrow visually
                myDraw.pop(); 
                oppDraw.pop();
            }
            
            centerStack.push(myC, oppC);
            activeRanks.right = myC.rank;
            activeRanks.left = oppC.rank; // Mirror logic handled by passing explicit cards
            
            placeCardInSlot(myC, 'slot-r'); // I always play right
            placeCardInSlot(oppC, 'slot-l'); // Opp plays left
            
            resetPasses();
            updateCounts();
        }

        function resetPasses() {
            hasPassed = { me: false, opp: false };
            isLocked = false;
            $('btn-me').innerText = "NEW CARD REVEAL";
            $('btn-me').classList.remove('ready', 'counting');
            $('btn-opp').innerText = oppNick;
            $('btn-opp').classList.remove('ready', 'counting');
        }

        // 8. SLAPS
        window.onkeydown = (e) => {
            if(e.code === 'Space' && !slapInProgress) {
                if(centerStack.length >= 2 && activeRanks.left === activeRanks.right && activeRanks.left !== null) {
                    if(isHost) processSlap('p1');
                    else conn.send({ type: 'SLAP_REQ' });
                }
            }
        };

        function processSlap(claimant) {
            if(slapInProgress) return;
            slapInProgress = true;
            
            // Winner is Claimant
            // Loser gets Center Stack
            let winner = claimant;
            let loser = (winner === 'p1') ? 'p2' : 'p1';
            
            // Host sends result
            conn.send({ type: 'SLAP_WIN', winner: winner, stack: centerStack });
            handleSlapWin(winner, centerStack);
        }

        function handleSlapWin(winner, stack) {
            slapInProgress = true;
            $('alert-box').innerText = (winner === (isHost?'p1':'p2')) ? "YOU WON SLAP!" : "OPP WON SLAP!";
            $('alert-box').style.display = 'block';
            
            // Math
            if(winner === (isHost?'p1':'p2')) stats.mySlaps++; else stats.oppSlaps++;
            updateScoreboard();
            
            // Penalties
            if(winner === 'p1') {
                if(isHost) oppPenalty.push(...stack); else myPenalty.push(...stack);
            } else {
                if(isHost) myPenalty.push(...stack); else oppPenalty.push(...stack);
            }
            
            centerStack = [];
            
            setTimeout(() => {
                $('alert-box').style.display = 'none';
                $('slot-l').innerHTML = ''; $('slot-r').innerHTML = '';
                activeRanks = { left: null, right: null };
                slapInProgress = false;
                resetPasses();
                updateCounts();
            }, 1500);
        }

        // 9. END ROUND & REPATRIATION
        function checkRoundWin() {
            if(myFoundation.length === 0) {
                // I won round
                conn.send({ type: 'ROUND_OVER', winner: isHost ? 'p1' : 'p2' });
                if(isHost) resolveRound('p1'); 
            }
        }

        function resolveRound(winnerId) {
            // HOST ONLY LOGIC
            let p1Total = [...myFoundation, ...myDraw, ...myPenalty]; // Host cards
            let p2Total = [...oppFoundation, ...oppDraw, ...oppPenalty]; // Joiner cards
            
            // 1. Repatriate (Return borrowed cards to owner)
            let allCards = [...p1Total, ...p2Total]; // Center stack handled next
            let p1Owned = allCards.filter(c => c.owner === 'p1');
            let p2Owned = allCards.filter(c => c.owner === 'p2');
            
            // 2. Penalty Assignment (Loser takes center)
            if(winnerId === 'p1') {
                // P1 Won. P2 takes center.
                p2Owned.push(...centerStack);
            } else {
                p1Owned.push(...centerStack);
            }
            
            // 3. Shuffle & Deal Next Round
            let p1NextFound = p1Owned.sort(()=>Math.random()-0.5).slice(0, 10);
            let p1NextDraw = p1Owned.slice(10);
            
            let p2NextFound = p2Owned.sort(()=>Math.random()-0.5).slice(0, 10);
            let p2NextDraw = p2Owned.slice(10);
            
            // 4. Update Stats
            if(winnerId === 'p1') stats.p1Rounds++; else stats.aiRounds++; // Using legacy keys for simplicity in map
            
            // 5. Send Sync
            let syncData = {
                type: 'SYNC_ROUND',
                p1Found: p1NextFound, p1Draw: p1NextDraw,
                p2Found: p2NextFound, p2Draw: p2NextDraw,
                stats: { myRounds: stats.p1Rounds, oppRounds: stats.aiRounds, mySlaps: stats.p1Slaps, oppSlaps: stats.aiSlaps },
                winner: winnerId
            };
            conn.send(syncData);
            
            // 6. Start Host
            alert(`${winnerId === 'p1' ? myNick : oppNick} WINS ROUND!`);
            startRound(p1NextFound, p1NextDraw, p2NextFound, p2NextDraw);
            
            // Update Host Scoreboard
            stats.myRounds = stats.p1Rounds;
            stats.oppRounds = stats.aiRounds;
            updateScoreboard();
        }

        // HELPERS
        function updateCounts() {
            let myTotal = myFoundation.length + myDraw.length + myPenalty.length;
            // Strict 52 Conservation: Opponent = 52 - MyTotal - Center
            let oppTotal = 52 - myTotal - centerStack.length;
            
            $('cnt-me').innerText = myTotal;
            $('cnt-opp').innerText = oppTotal;
        }
        
        function updateLabels() {
            $('lbl-me').innerText = myNick;
            $('lbl-opp').innerText = oppNick;
        }
        
        function updateScoreboard() {
            $('s-mr').innerText = stats.myRounds;
            $('s-ms').innerText = stats.mySlaps;
            $('s-or').innerText = stats.oppRounds;
            $('s-os').innerText = stats.oppSlaps;
        }

        function removeFromFoundation(arr, r, s) {
            // Find index of card with rank r and suit s
            let idx = arr.findIndex(c => c.rank === r && c.s === s);
            if(idx > -1) arr.splice(idx, 1);
            else arr.pop(); // Fallback if sync lag
        }

        function borrowCards(player) {
            // Logic handled by Host in resolveRound, but for visuals during round:
            // If p1 empty, split p2.
            // Simplified: Just set isBorrowing flag for visuals.
            if(player === 'p1') isBorrowing.me = true;
            else isBorrowing.opp = true;
        }
        
        function endGame(winner) {
            $('victory-overlay').style.display = 'flex';
            $('vic-msg').innerText = (winner === 'me') ? "YOU WIN THE MATCH!" : "YOU LOSE THE MATCH!";
        }

    })();
    </script>
</body>
</html>
