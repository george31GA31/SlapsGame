/* =========================================
   TOURNAMENT-ONLINE.JS
   (Dedicated Logic for Bracket Matches)
   ========================================= */

const gameState = {
    // --- Card State ---
    playerDeck: [], aiDeck: [],
    playerHand: [], aiHand: [],
    centerPileLeft: [], centerPileRight: [],
    globalZ: 1000,
    playerTotal: 26, aiTotal: 26,

    // --- Game Flags ---
    gameActive: false,
    matchEnded: false,
    playerReady: false, aiReady: false,
    drawLock: false,
    countdownRunning: false,
    slapActive: false,
    lastSpacebarTime: 0,

    // --- Penalties ---
    playerYellows: 0, playerReds: 0,
    aiYellows: 0, aiReds: 0,

    // --- Multiplayer State ---
    isHost: false,
    peer: null,
    conn: null,
    myId: null,
    roomCode: null,
    myName: "ME",
    opponentName: "OPPONENT",
    handshakeDone: false,
    roundStarted: false,

    // --- Visuals ---
    lastDraggedCard: null,
    lastDraggedEl: null,
    opponentDragGhosts: new Map(),
    moveSeq: 0,

    // --- Scoreboard Stats ---
    p1Rounds: 0, aiRounds: 0,
    p1Slaps: 0, aiSlaps: 0
};

const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king', 'ace'];
const CARD_BACK_SRC = 'assets/cards/back_of_card.png';
const PLAYER_LANES = [5, 29, 53, 77];

class Card {
    constructor(suit, rank, value, id) {
        this.suit = suit; this.rank = rank; this.value = value;
        this.id = id || Math.random().toString(36).substr(2, 9);
        this.imgSrc = `assets/cards/${rank}_of_${suit}.png`;
        this.isFaceUp = false; this.owner = null;
        this.element = null; this.laneIndex = 0;
        this.originalLeft = null; this.originalTop = null;
    }
}

// ==========================================
// 1. BOOTSTRAP (Tournament Specific)
// ==========================================

window.onload = function() {
    // Standard Listeners
    document.addEventListener('keydown', handleInput);
    const pDeck = document.getElementById('player-draw-deck');
    if (pDeck) pDeck.onclick = handlePlayerDeckClick;

    // Load Identity
    gameState.myName = localStorage.getItem('isf_my_name') || "Player";
    
    // START TOURNAMENT CONNECTION IMMEDIATELY
    initTournamentMatch();
};

function initTournamentMatch() {
    // 1. Get the specific Match Data set by the bracket
    const role = localStorage.getItem('isf_role'); // 'host' or 'guest'
    const matchCode = localStorage.getItem('isf_code'); // e.g. 'MATCH-LQF-1'
    const oppName = localStorage.getItem('isf_tourney_opponent');

    if (!matchCode || !role) {
        console.error("CRITICAL: Missing Tournament Data. Cannot connect.");
        alert("Error: Match data missing. Returning to lobby.");
        returnToTournament(false); 
        return;
    }

    // 2. Setup State
    gameState.isHost = (role === 'host');
    gameState.roomCode = matchCode;
    gameState.opponentName = oppName || "Opponent";
    updateScoreboardWidget();

    console.log(`Initializing Tournament Match. ID: ${matchCode}, Role: ${role}`);

    // 3. Initialize PeerJS with the MATCH CODE
    // This creates a private channel just for these two players.
    gameState.peer = gameState.isHost ? new Peer(matchCode) : new Peer();

    gameState.peer.on('open', (id) => {
        gameState.myId = id;
        console.log("My Peer ID:", id);

        if (gameState.isHost) {
            // Host waits for specific guest
            gameState.peer.on('connection', (conn) => bindConnection(conn));
        } else {
            // Guest connects to the Match ID
            const conn = gameState.peer.connect(matchCode, { reliable: true });
            bindConnection(conn);
        }
    });

    gameState.peer.on('error', (err) => {
        console.error("Peer Error:", err);
        if (err.type === 'unavailable-id') {
            // This usually means the match is already running or didn't close properly.
            console.log("ID taken, attempting to connect anyway (might be reconnecting)...");
        }
    });
}

function bindConnection(conn) {
    gameState.conn = conn;

    conn.on('open', () => {
        console.log("Connected to Opponent!");
        // Immediate Handshake
        sendNet({ type: 'HANDSHAKE', name: gameState.myName });
    });

    conn.on('data', (msg) => handleNet(msg));

    conn.on('close', () => {
        if (!gameState.matchEnded) {
            // Don't auto-quit, opponent might reconnect? 
            // For tournament, usually strictly end it.
            // showEndGame("OPPONENT DISCONNECTED", true);
        }
    });
}

function sendNet(obj) {
    if (gameState.conn && gameState.conn.open) {
        gameState.conn.send(obj);
    }
}

// ==========================================
// 2. NETWORK HANDLER
// ==========================================

function handleNet(msg) {
    if (!msg) return;

    if (msg.type === 'HANDSHAKE') {
        // Ensure names are synced
        if (msg.name) {
            gameState.opponentName = msg.name;
            updateScoreboardWidget();
        }
        
        if (!gameState.handshakeDone) {
            gameState.handshakeDone = true;
            // Send my name back if I haven't yet
            sendNet({ type: 'HANDSHAKE', name: gameState.myName });
        }

        // Host starts the game once handshake is verified
        if (gameState.isHost && !gameState.roundStarted) {
            gameState.roundStarted = true;
            startRoundHostAuthoritative();
        }
        return;
    }

    // --- GAMEPLAY MESSAGES (Standard) ---
    if (msg.type === 'ROUND_START') {
        if (!gameState.isHost) startRoundJoinerFromState(msg.state);
    }
    else if (msg.type === 'READY') {
        gameState.aiReady = true;
        document.getElementById('ai-draw-deck')?.classList.add('deck-ready');
        checkDrawConditionMultiplayer();
    }
    else if (msg.type === 'HOST_COUNTDOWN') startCountdownFromHost();
    else if (msg.type === 'REVEAL_PRELOAD') applyRevealPreload(msg.result);
    else if (msg.type === 'REVEAL_SHOW') applyRevealShow();
    else if (msg.type === 'DRAG') applyOpponentDrag(msg.drag);
    else if (msg.type === 'MOVE_REQ') { if (gameState.isHost) adjudicateMove(msg.move, 'ai'); }
    else if (msg.type === 'MOVE_APPLY') applyMoveFromHost(msg.apply);
    else if (msg.type === 'MOVE_REJECT') rejectMoveFromHost(msg.reject);
    else if (msg.type === 'OPPONENT_REJECT') cleanupGhost(msg.card);
    else if (msg.type === 'OPPONENT_FLIP') {
        const c = gameState.aiHand.find(x => x.id === msg.cardId);
        if (c && c.element) setCardFaceUp(c.element, c, 'ai');
    }
    
    // --- SLAP & SCORING ---
    else if (msg.type === 'SLAP_REQ') { if (gameState.isHost) adjudicateSlap('ai'); }
    else if (msg.type === 'SLAP_UPDATE') applySlapUpdate(msg);
    else if (msg.type === 'PENALTY_UPDATE') applyPenaltyUpdate(msg);
    else if (msg.type === 'ROUND_OVER') applyRoundOver(msg);
    else if (msg.type === 'MATCH_OVER') applyMatchOver(msg);
    
    // --- OPPONENT LEFT ---
    else if (msg.type === 'OPPONENT_LEFT') {
        if (!gameState.matchEnded) {
            showEndGame("VICTORY (OPPONENT LEFT)", true);
        }
    }
}

// ==========================================
// 3. TOURNAMENT EXIT LOGIC (Crucial)
// ==========================================

function showEndGame(title, isWin) {
    gameState.matchEnded = true; 

    const modal = document.getElementById('game-message');
    if (!modal) return;
    
    modal.querySelector('h1').innerText = title;
    modal.querySelector('h1').style.color = isWin ? '#66ff66' : '#ff7575';

    const contentArea = modal.querySelector('p');
    
    // TOURNAMENT SPECIFIC BUTTONS
    contentArea.innerHTML = `
        <div style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
            <button class="btn-action-small" onclick="returnToTournament(${isWin})" style="background:#00ccff; width:auto; padding: 15px 30px;">
                ${isWin ? "CONTINUE TO BRACKET" : "RETURN TO LOBBY"}
            </button>
        </div>
    `;
    
    const oldBtn = document.getElementById('msg-btn');
    if (oldBtn) oldBtn.classList.add('hidden');
    
    modal.classList.remove('hidden');
}

function returnToTournament(didWin) {
    // 1. Destroy Peer Connection to free up the Match ID
    if (gameState.peer) {
        gameState.peer.destroy();
    }

    // 2. Clear LocalStorage flags for this specific match
    localStorage.removeItem('isf_role');
    localStorage.removeItem('isf_code');
    localStorage.removeItem('isf_tourney_opponent');

    // 3. Signal Parent Window (The Bracket)
    // This tells friend-tournament.js to close the iframe and update the bracket
    window.parent.postMessage({ 
        type: 'GAME_OVER', 
        result: didWin ? 'win' : 'loss' 
    }, '*');
}

// ==========================================
// 4. GAMEPLAY LOGIC (Condensed & Fixed)
// ==========================================

function handleInput(e) {
    if (e.code === 'Space') {
        e.preventDefault();
        if (!gameState.gameActive) return;
        const now = Date.now();
        if (now - gameState.lastSpacebarTime < 400) return;
        gameState.lastSpacebarTime = now;

        if (gameState.isHost) adjudicateSlap('player');
        else sendNet({ type: 'SLAP_REQ' });
    }
}

async function startRoundHostAuthoritative() {
    gameState.matchEnded = false;
    let fullDeck = createDeck();
    shuffle(fullDeck);

    // Score Checks
    if (gameState.playerTotal <= 0) { showEndGame("YOU WIN THE MATCH!", true); return; }
    if (gameState.aiTotal <= 0) { showEndGame("OPPONENT WINS THE MATCH!", false); return; }

    // Dealing Logic
    const pTotal = gameState.playerTotal;
    const pAll = fullDeck.slice(0, pTotal);
    const aAll = fullDeck.slice(pTotal, 52);
    
    const pHand = pAll.splice(0, Math.min(10, pTotal));
    gameState.playerDeck = pAll;
    
    const aHand = aAll.splice(0, Math.min(10, 52 - pTotal));
    gameState.aiDeck = aAll;

    // Reset Visuals
    await preloadCardImages([...pHand, ...aHand]);
    
    dealSmartHand(pHand, 'player');
    dealSmartHand(aHand, 'ai');
    resetCenterPiles();
    checkDeckVisibility();

    // Prepare State for Guest
    const guestState = {
        playerTotal: gameState.aiTotal,
        aiTotal: gameState.playerTotal,
        playerDeck: gameState.aiDeck.map(packCard),
        aiDeck: gameState.playerDeck.map(packCard),
        playerHand: aHand.map(packCard),
        aiHand: pHand.map(packCard),
        centerPileLeft: [], centerPileRight: []
    };

    sendNet({ type: 'ROUND_START', state: guestState });
}

async function startRoundJoinerFromState(state) {
    importState(state);
    await preloadCardImages([...gameState.playerHand, ...gameState.aiHand]);
    dealSmartHand(gameState.playerHand, 'player');
    dealSmartHand(gameState.aiHand, 'ai');
    resetCenterPiles();
    checkDeckVisibility();
    updateScoreboard();
    updateScoreboardWidget();
}

function handleRoundOver(winner) {
    if (winner === 'player') {
        gameState.aiTotal = 52 - gameState.playerTotal;
        gameState.p1Rounds++; 
    } else {
        gameState.playerTotal = 52 - gameState.aiTotal;
        gameState.aiRounds++; 
    }

    if (gameState.playerTotal <= 0 || gameState.aiTotal >= 52) {
        const payload = { type: 'MATCH_OVER', winner: 'player' };
        sendNet(payload);
        applyMatchOver(payload);
    } else if (gameState.aiTotal <= 0 || gameState.playerTotal >= 52) {
        const payload = { type: 'MATCH_OVER', winner: 'ai' };
        sendNet(payload);
        applyMatchOver(payload);
    } else {
        const payload = {
            type: 'ROUND_OVER',
            winner: winner,
            pTotal: gameState.playerTotal,
            aTotal: gameState.aiTotal,
            p1Rounds: gameState.p1Rounds, 
            aiRounds: gameState.aiRounds
        };
        sendNet(payload);
        applyRoundOver(payload);
    }
}

function applyRoundOver(data) {
    gameState.gameActive = false;
    
    if (gameState.isHost) {
        gameState.playerTotal = data.pTotal;
        gameState.aiTotal = data.aTotal;
    } else {
        gameState.playerTotal = data.aTotal; 
        gameState.aiTotal = data.pTotal;    
    }
    gameState.p1Rounds = data.p1Rounds;  
    gameState.aiRounds = data.aiRounds;  

    updateScoreboard();
    updateScoreboardWidget(); 

    const iAmHost = gameState.isHost;
    const hostWon = (data.winner === 'player');
    const iWon = (iAmHost && hostWon) || (!iAmHost && !hostWon);
    
    showRoundMessage(iWon ? "ROUND WON!" : "ROUND LOST!", 
        iWon ? `Next round: ${gameState.playerTotal} cards.` : `Next round: ${gameState.aiTotal} cards.`);
}

function showRoundMessage(title, sub) {
    const modal = document.getElementById('game-message');
    if (!modal) return;
    modal.querySelector('h1').innerText = title;
    modal.querySelector('p').innerText = sub;
    
    const btn = document.getElementById('msg-btn');
    if (btn) {
        btn.classList.remove('hidden');
        if (gameState.isHost) {
            btn.innerText = "START NEXT ROUND";
            btn.onclick = () => {
                modal.classList.add('hidden');
                startRoundHostAuthoritative();
            };
        } else {
            btn.innerText = "WAITING FOR HOST...";
            btn.onclick = null;
        }
    }
    modal.classList.remove('hidden');
}

function applyMatchOver(data) {
    gameState.gameActive = false;
    const iAmHost = gameState.isHost;
    const hostWon = (data.winner === 'player');
    const iWon = (iAmHost && hostWon) || (!iAmHost && !hostWon);
    showEndGame(iWon ? "YOU WON THE MATCH!" : "OPPONENT WINS!", iWon);
}

// ==========================================
// 5. HELPER FUNCTIONS (Copy-Pasted & Cleaned)
// ==========================================

function updateScoreboardWidget() {
    const p1 = document.getElementById('sb-p1-name');
    const p2 = document.getElementById('sb-p2-name');
    if(p1) p1.innerText = gameState.myName;
    if(p2) p2.innerText = gameState.opponentName;
    
    document.getElementById('sb-p1-rounds').innerText = gameState.p1Rounds;
    document.getElementById('sb-p2-rounds').innerText = gameState.aiRounds;
    document.getElementById('sb-p1-slaps').innerText = gameState.p1Slaps;
    document.getElementById('sb-p2-slaps').innerText = gameState.aiSlaps;
    
    const oppLabel = document.getElementById('opponent-display-name');
    if (oppLabel) oppLabel.innerText = gameState.opponentName.toUpperCase();
}

function checkDeckVisibility() {
    document.getElementById('player-draw-deck')?.classList.remove('hidden');
    document.getElementById('ai-draw-deck')?.classList.remove('hidden');
}

function resetCenterPiles() {
    gameState.centerPileLeft = [];
    gameState.centerPileRight = [];
    document.getElementById('center-pile-left').innerHTML = '';
    document.getElementById('center-pile-right').innerHTML = '';
    gameState.slapActive = false;
    document.getElementById('game-message')?.classList.add('hidden');
    
    if (gameState.opponentDragGhosts) {
        gameState.opponentDragGhosts.forEach(el => el.remove()); 
        gameState.opponentDragGhosts.clear(); 
    }
}

function createDeck() {
    let deck = [];
    SUITS.forEach(s => RANKS.forEach((r,i) => deck.push(new Card(s,r,i+2))));
    return deck;
}
function shuffle(a) { for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

function packCard(c) { return {suit:c.suit, rank:c.rank, value:c.value, id:c.id}; }
function unpackCard(o) { return new Card(o.suit, o.rank, o.value, o.id); }
function packCardWithMeta(c) { return { suit: c.suit, rank: c.rank, value: c.value, id: c.id, isFaceUp: !!c.isFaceUp, owner: c.owner, laneIndex: c.laneIndex }; }

function importState(s) {
    gameState.playerTotal = s.playerTotal;
    gameState.aiTotal = s.aiTotal;
    gameState.playerDeck = (s.playerDeck||[]).map(unpackCard);
    gameState.aiDeck = (s.aiDeck||[]).map(unpackCard);
    gameState.playerHand = (s.playerHand||[]).map(unpackCard);
    gameState.aiHand = (s.aiHand||[]).map(unpackCard);
}

function updateScoreboard() {
    document.getElementById('score-player').innerText = gameState.playerTotal;
    document.getElementById('score-ai').innerText = gameState.aiTotal;
}

// --- CARD RENDERING & DRAG (Must be present) ---
function dealSmartHand(cards, owner) {
    const container = document.getElementById(`${owner}-foundation-area`);
    if (!container) return;
    container.innerHTML = '';
    if (owner === 'player') gameState.playerHand = []; else gameState.aiHand = [];

    const piles = [[], [], [], []];
    if (cards.length >= 10) {
        let cardIdx = 0;
        [4, 3, 2, 1].forEach((size, i) => { for (let j = 0; j < size; j++) piles[i].push(cards[cardIdx++]); });
    } else {
        let pileIdx = 0;
        cards.forEach(card => { piles[pileIdx].push(card); pileIdx = (pileIdx + 1) % 4; });
    }

    const laneOrder = (owner === 'ai') ? [3, 2, 1, 0] : [0, 1, 2, 3];
    laneOrder.forEach((laneIdx, displayIdx) => {
        const pile = piles[laneIdx];
        if (!pile) return;
        pile.forEach((card, index) => {
            const img = document.createElement('img');
            img.className = 'game-card';
            card.owner = owner;
            card.laneIndex = laneIdx;
            const isTopCard = (index === pile.length - 1);
            if (isTopCard) setCardFaceUp(img, card, owner); else setCardFaceDown(img, card, owner);
            img.style.left = `${PLAYER_LANES[displayIdx]}%`;
            const stackOffset = index * 5;
            img.style.top = (owner === 'ai') ? `${10 + stackOffset}px` : `${60 - stackOffset}px`;
            img.style.zIndex = index + 10;
            card.element = img;
            container.appendChild(img);
            if (owner === 'player') gameState.playerHand.push(card); else gameState.aiHand.push(card);
        });
    });
}

function setCardFaceUp(img, card, owner) {
    img.src = card.imgSrc;
    img.classList.remove('card-face-down');
    card.isFaceUp = true;
    if (owner === 'player') {
        img.classList.add('player-card');
        img.onclick = null;
        makeDraggable(img, card);
    } else {
        img.classList.add('opponent-card');
    }
}

function setCardFaceDown(img, card, owner) {
    img.src = CARD_BACK_SRC;
    img.classList.add('card-face-down');
    card.isFaceUp = false;
    if (owner === 'player') img.onclick = () => tryFlipCard(img, card);
}

function tryFlipCard(img, card) {
    const liveCards = gameState.playerHand.filter(c => c.isFaceUp).length;
    if (liveCards < 4) {
        setCardFaceUp(img, card, 'player');
        sendNet({ type: 'OPPONENT_FLIP', cardId: card.id });
    }
}

function makeDraggable(img, cardData) {
    img.onmousedown = (e) => {
        e.preventDefault();
        gameState.globalZ++;
        img.style.zIndex = gameState.globalZ;
        img.style.transition = 'none';
        cardData.originalLeft = img.style.left;
        cardData.originalTop = img.style.top;
        gameState.lastDraggedCard = cardData;
        gameState.lastDraggedEl = img;

        const box = document.getElementById('player-foundation-area');
        if (!box) return;
        const boxRect = box.getBoundingClientRect();
        let shiftX = e.clientX - img.getBoundingClientRect().left;
        let shiftY = e.clientY - img.getBoundingClientRect().top;

        function moveAt(pageX, pageY, sendDrag) {
            let newLeft = pageX - shiftX - boxRect.left;
            let newTop = pageY - shiftY - boxRect.top;
            if (newTop < 0 && (!gameState.gameActive || !checkLegalPlay(cardData))) newTop = 0;
            img.style.left = newLeft + 'px';
            img.style.top = newTop + 'px';
            
            if (sendDrag) {
                const nx = (img.offsetWidth/2 + newLeft) / boxRect.width;
                const ny = (img.offsetHeight/2 + newTop) / boxRect.height;
                sendNet({ type: 'DRAG', drag: { id: cardKey(cardData), nx, ny, phase: 'move', src: cardData.imgSrc } });
            }
        }
        
        moveAt(e.pageX, e.pageY, false);
        sendNet({ type: 'DRAG', drag: { id: cardKey(cardData), nx:0, ny:0, phase: 'start', src: cardData.imgSrc } });

        function onMouseMove(event) { moveAt(event.pageX, event.pageY, true); }
        function onMouseUp(event) {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            img.style.transition = 'all 0.1s ease-out';
            if (gameState.gameActive && parseInt(img.style.top) < -10) {
                const dropSide = getDropSide(img, event);
                requestMoveToHost(cardData, dropSide);
            } else {
                sendNet({ type: 'DRAG', drag: { id: cardKey(cardData), nx:0, ny:0, phase: 'end' } });
            }
        }
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    };
}

function requestMoveToHost(cardData, dropSide) {
    if (dropSide !== 'left' && dropSide !== 'right') {
        if (cardData && cardData.originalLeft != null) {
            const el = cardData.element;
            if (el) { el.style.left = cardData.originalLeft; el.style.top = cardData.originalTop; }
        }
        return;
    }
    
    let targetId = null;
    if (dropSide === 'left' && gameState.centerPileLeft.length > 0) targetId = gameState.centerPileLeft[gameState.centerPileLeft.length-1].id;
    if (dropSide === 'right' && gameState.centerPileRight.length > 0) targetId = gameState.centerPileRight[gameState.centerPileRight.length-1].id;

    let targetSideForHost = dropSide;
    if (!gameState.isHost) targetSideForHost = (dropSide === 'left') ? 'right' : 'left';

    const req = {
        reqId: `${gameState.myId}:${Date.now()}:${(++gameState.moveSeq)}`,
        dropSide: targetSideForHost, targetId: targetId, card: packCardWithMeta(cardData)
    };

    if (gameState.isHost) adjudicateMove(req, 'player');
    else sendNet({ type: 'MOVE_REQ', move: req });
}

function checkLegalPlay(card) {
    if (!gameState.gameActive) return false;
    return checkPileLogic(card, gameState.centerPileLeft) || checkPileLogic(card, gameState.centerPileRight);
}
function checkPileLogic(card, targetPile) {
    if (targetPile.length === 0) return false;
    const targetCard = targetPile[targetPile.length - 1];
    const diff = Math.abs(card.value - targetCard.value);
    return (diff === 1 || diff === 12);
}
function getDropSide(imgElement, mouseEvent) {
    const l = document.getElementById('center-pile-left').getBoundingClientRect();
    const r = document.getElementById('center-pile-right').getBoundingClientRect();
    const x = mouseEvent.clientX; const y = mouseEvent.clientY; const pad = 25;
    if (x >= (l.left - pad) && x <= (l.right + pad) && y >= (l.top - pad) && y <= (l.bottom + pad)) return 'left';
    if (x >= (r.left - pad) && x <= (r.right + pad) && y >= (r.top - pad) && y <= (r.bottom + pad)) return 'right';
    return null;
}
function cardKey(c) { return `${c.suit}:${c.rank}:${c.value}:${c.owner}:${c.laneIndex}`; }
async function preloadCardImages(cards) {
    const urls = new Set(); urls.add(CARD_BACK_SRC);
    (cards || []).forEach(c => { if (c && c.imgSrc) urls.add(c.imgSrc); });
    const tasks = [];
    urls.forEach((src) => { tasks.push(new Promise((resolve) => { const img = new Image(); img.onload = () => resolve(true); img.onerror = () => resolve(false); img.src = src; })); });
    await Promise.race([ Promise.all(tasks), new Promise(resolve => setTimeout(resolve, 2500)) ]);
}

// --- MISSING ADJUDICATION & SLAP LOGIC FILLERS ---
// (Paste these from your original if they were missing, but simplified versions here for safety)

function adjudicateMove(m, moverOverride) {
    const mover = moverOverride || 'ai';
    const moverHand = (mover === 'player') ? gameState.playerHand : gameState.aiHand;
    const idx = moverHand.findIndex(c => c.id === m.card.id);
    if (idx === -1) { if(mover==='ai') sendNet({ type: 'MOVE_REJECT', reject: { cardId: m.card.id } }); return; }
    
    const cardObj = moverHand[idx];
    let pile = (m.dropSide === 'left') ? gameState.centerPileLeft : gameState.centerPileRight;
    
    // Strict Check
    const currentTop = (pile.length > 0) ? pile[pile.length - 1] : null;
    if ((currentTop && m.targetId !== currentTop.id) || !checkPileLogic(cardObj, pile)) {
        if (mover === 'ai') {
            sendNet({ type: 'MOVE_REJECT', reject: { cardId: m.card.id } });
            cleanupGhost(m.card);
        } else {
            rejectMoveFromHost({ cardId: cardObj.id });
            sendNet({ type: 'OPPONENT_REJECT', card: m.card });
        }
        return;
    }
    const applyPayload = applyMoveAuthoritative(mover, cardObj, m.dropSide, m.reqId);
    sendNet({ type: 'MOVE_APPLY', apply: applyPayload });
}

function applyMoveAuthoritative(mover, cardObj, side, reqId) {
    // Kill Ghost
    gameState.opponentDragGhosts.forEach((ghostEl, key) => {
        if(key.includes(cardObj.suit) && key.includes(cardObj.rank)) { ghostEl.remove(); gameState.opponentDragGhosts.delete(key); }
    });

    const targetPile = (side === 'left') ? gameState.centerPileLeft : gameState.centerPileRight;
    targetPile.push(cardObj);
    
    let hand = (mover === 'player') ? gameState.playerHand : gameState.aiHand;
    if (mover === 'player') { gameState.playerHand = hand.filter(c => c !== cardObj); gameState.playerTotal--; }
    else { gameState.aiHand = hand.filter(c => c !== cardObj); gameState.aiTotal--; }
    
    if (cardObj.element) cardObj.element.remove();
    renderCenterPile(side, cardObj);
    updateScoreboard();
    checkSlapCondition();

    // Reveal logic
    let newTopCardPayload = null;
    const laneCards = hand.filter(c => c.laneIndex === cardObj.laneIndex);
    if (laneCards.length > 0) {
        const newTop = laneCards[laneCards.length - 1];
        if (mover === 'player') newTopCardPayload = packCardWithMeta(newTop);
        if (mover === 'ai' && !newTop.isFaceUp && newTop.element) setCardFaceUp(newTop.element, newTop, 'ai');
    }

    if (gameState.playerHand.length === 0) handleRoundOver('player');
    else if (gameState.aiHand.length === 0) handleRoundOver('ai');

    return { mover, side, card: packCardWithMeta(cardObj), playerTotal: gameState.playerTotal, aiTotal: gameState.aiTotal, newTopCard: newTopCardPayload };
}

function applyMoveFromHost(a) {
    const localMover = (a.mover === 'player') ? 'ai' : 'player';
    const localSide = (a.side === 'left') ? 'right' : 'left';
    gameState.playerTotal = a.aiTotal; gameState.aiTotal = a.playerTotal;
    
    // Find Card
    const hand = (localMover === 'player') ? gameState.playerHand : gameState.aiHand;
    let idx = hand.findIndex(c => c.id === a.card.id);
    if (idx === -1) idx = hand.findIndex(c => c.suit === a.card.suit && c.rank === a.card.rank);
    
    let cardObj = null;
    if (idx !== -1) { cardObj = hand[idx]; hand.splice(idx, 1); } else { cardObj = unpackCard(a.card); }
    if (cardObj.element) { cardObj.element.remove(); cardObj.element = null; }

    const pile = (localSide === 'left') ? gameState.centerPileLeft : gameState.centerPileRight;
    pile.push(cardObj);
    renderCenterPile(localSide, cardObj);
    updateScoreboard();
    checkSlapCondition();

    if (a.newTopCard && localMover === 'ai') {
        const c = gameState.aiHand.find(x => x.suit === a.newTopCard.suit && x.rank === a.newTopCard.rank);
        if (c && c.element) setCardFaceUp(c.element, c, 'ai');
    }
}

function rejectMoveFromHost(j) {
    let card = gameState.playerHand.find(c => c.id === j.cardId) || gameState.lastDraggedCard;
    if (card && card.element) {
        card.element.style.transition = 'all 0.3s ease-out';
        card.element.style.left = card.originalLeft;
        card.element.style.top = card.originalTop;
        setTimeout(() => { card.element.style.zIndex = card.laneIndex + 10; }, 300);
    }
}

function cleanupGhost(cardData) {
    gameState.opponentDragGhosts.forEach((ghostEl, key) => {
        if (key.includes(cardData.suit) && key.includes(cardData.rank)) {
            ghostEl.remove();
            gameState.opponentDragGhosts.delete(key);
        }
    });
}

function applyOpponentDrag(d) {
    const box = document.getElementById('ai-foundation-area');
    if (!box) return;
    const boxRect = box.getBoundingClientRect();
    let el = gameState.opponentDragGhosts.get(d.id);
    
    if (d.phase === 'start' && !el) {
        el = document.createElement('img');
        el.className = 'game-card opponent-card';
        el.src = d.src || 'assets/cards/back_of_card.png';
        el.style.position = 'absolute'; el.style.zIndex = 5000; el.style.pointerEvents = 'none';
        box.appendChild(el);
        gameState.opponentDragGhosts.set(d.id, el);
    }
    if (el) {
        el.style.left = ((1 - d.nx) * boxRect.width - (el.offsetWidth/2)) + 'px';
        el.style.top = ((1 - d.ny) * boxRect.height - (el.offsetHeight/2)) + 'px';
        if (d.phase === 'end') { el.remove(); gameState.opponentDragGhosts.delete(d.id); }
    }
}

// --- SLAP LOGIC ---
function checkSlapCondition() {
    if (gameState.centerPileLeft.length === 0 || gameState.centerPileRight.length === 0) { gameState.slapActive = false; return; }
    const topL = gameState.centerPileLeft[gameState.centerPileLeft.length - 1];
    const topR = gameState.centerPileRight[gameState.centerPileRight.length - 1];
    gameState.slapActive = (topL.rank === topR.rank);
}

function adjudicateSlap(who) {
    if (!gameState.gameActive) return;
    if (gameState.slapActive) {
        gameState.gameActive = false;
        const pilesTotal = gameState.centerPileLeft.length + gameState.centerPileRight.length;
        if (who === 'player') gameState.aiTotal += pilesTotal; else gameState.playerTotal += pilesTotal;
        gameState.centerPileLeft = []; gameState.centerPileRight = []; gameState.slapActive = false;
        const update = { type: 'SLAP_UPDATE', winner: who, pTotal: gameState.playerTotal, aTotal: gameState.aiTotal };
        sendNet(update); applySlapUpdate(update);
    } else {
        // Penalty logic here (simplified)
    }
}

function applySlapUpdate(data) {
    gameState.gameActive = false; gameState.slapActive = false;
    const iAmHost = gameState.isHost;
    const hostWon = (data.winner === 'player');
    const iWon = (iAmHost && hostWon) || (!iAmHost && !hostWon);
    
    const overlay = document.getElementById('slap-overlay');
    const txt = document.getElementById('slap-text');
    if (overlay) {
        txt.innerText = iWon ? "YOU WON SLAP!" : "OPPONENT WON SLAP!";
        overlay.classList.remove('hidden');
    }
    
    if(gameState.isHost) { gameState.playerTotal = data.pTotal; gameState.aiTotal = data.aTotal; }
    else { gameState.playerTotal = data.aTotal; gameState.aiTotal = data.pTotal; }
    updateScoreboard();

    setTimeout(() => {
        gameState.centerPileLeft = []; gameState.centerPileRight = [];
        document.getElementById('center-pile-left').innerHTML = '';
        document.getElementById('center-pile-right').innerHTML = '';
        overlay?.classList.add('hidden');
        if (gameState.playerTotal <= 0) showEndGame("YOU WIN!", true);
        if (gameState.aiTotal <= 0) showEndGame("OPPONENT WINS!", false);
    }, 2000);
}

// --- COUNTDOWN HELPERS ---
function handlePlayerDeckClick() {
    if (!gameState.gameActive) {
        if(gameState.playerReady) return;
        gameState.playerReady = true;
        document.getElementById('player-draw-deck')?.classList.add('deck-ready');
        sendNet({ type: 'READY' });
        checkDrawConditionMultiplayer();
    }
}
function checkDrawConditionMultiplayer() {
    if (gameState.playerReady && gameState.aiReady && gameState.isHost && !gameState.countdownRunning) {
        sendNet({ type: 'HOST_COUNTDOWN' });
        startCountdownFromHost();
    }
}
function startCountdownFromHost() {
    gameState.countdownRunning = true;
    const ov = document.getElementById('countdown-overlay');
    ov?.classList.remove('hidden');
    let c = 3;
    if(ov) ov.innerText = c;
    const t = setInterval(() => {
        c--;
        if (c > 0) { 
            if(ov) ov.innerText = c;
            if (c===1 && gameState.isHost) {
                const res = performRevealHostOnly();
                sendNet({ type: 'REVEAL_PRELOAD', result: res });
                applyRevealPreload(res); // Local apply
            }
        } else {
            clearInterval(t);
            ov?.classList.add('hidden');
            gameState.countdownRunning = false;
            if (gameState.isHost) { sendNet({ type: 'REVEAL_SHOW' }); applyRevealShow(); }
        }
    }, 800);
}
